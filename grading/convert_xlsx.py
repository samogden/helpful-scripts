# -*- coding: utf-8 -*-
"""CS 3013 - Operating Systems TA Grading Assistant.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1u38WJpLdNSsigxDPEmJV-675LJnq6O4_

##Video Response Grading Helper

1) Generate HTML for easy form filling (grades recording). 

2) Generate .zip file as feedback attachment.

Report Any Issues: shou@wpi.edu

**Update Log**

1.   Blank line bug fixed: Feb. 8
2.   Default comment support. Feb. 22
3.   The naming of the .xlsx and .html files can be arbitrary (but the extensions should still match.) Feb. 26
4.   The feedbacks now contain scores of all questions. Feb. 26

Upload these files in the temporary space:

1) **.xlsx (upload the video response grading file.)

2) **.html (copy the table DOM element <table width="50%" class="zebra>, create a new file with this extension and paste the content into this file)

## 1. Grade Entry Easy Fill

Run this script to automatically fill the **Grade Entry** form
"""

import logging
import os
import argparse
import shutil
import zipfile

import numpy as np
import pandas as pd
import bs4


def get_default_score_func(override_default_scores=None):
  if override_default_scores is not None:
    default_scores = override_default_scores
  else:
    ## Add new default scores here
    default_scores = {
      0 : 0.,
    }

  def default_score_func(idx):
    try:
      return default_scores[idx]
    except KeyError:
      return 0.
  return default_score_func


def get_default_answers_func(override_default_answers=None):
  if override_default_answers is not None:
    default_answers = override_default_answers
  else:
    ## Add new default answers here
    default_answers = {
      0 : "(No specific comments)",
    }

  def default_answers_func(idx):
    try:
      return default_answers[idx]
    except KeyError:
      return "(No specific comments)"
  return default_answers_func



class Student(object):
  def __init__(self, student_name, username, scores, comments):
    self.student_name = self.__class__.fix_name(student_name)
    self.username = username
    self.scores = scores
    self.comments = comments
    self.html_identifier = -1

  @staticmethod
  def fix_name(name):
    try:
      surname, firname = name.split(",")
      surname = surname.strip()
      firname = firname.strip()
      return f"{firname} {surname}"
    except Exception as e:
      return name

  def __str__(self):
    return f"{self.student_name} ({self.username}) : {np.sum(self.scores)}={'+'.join([str(s) for s in self.scores])} : {'|'.join(self.comments)}"

  def get_comment(self):
    comment_str = ""
    comment_str += f"{self.student_name} ({self.username})\n"
    comment_str += "\n"
    comment_str += f"Comments:\n"
    for idx, (score, comment) in enumerate(zip(self.scores, self.comments)):
      comment_str += f"  Q{idx + 1} : {score} points : {comment}\n"
    comment_str += "\n"
    comment_str += f"Total Score : {np.sum(self.scores)} = {' + '.join([str(s) for s in self.scores])}"
    return comment_str

  def get_score(self):
    return np.sum(self.scores)

class AssignmentNumberException(Exception):
  pass

def load_excel_to_students_dict(
    path_to_excel,
    default_score_func,
    default_answer_func):
  """Takes an xlsx file and returns a dictionary of student objects with keys of student name"""
  df = pd.read_excel(path_to_excel)

  # Combines alternating columns and assumes they're (score, comment) pairs
  question_comment_column_header_pairs = list(zip(df.columns[2::2], df.columns[3::2]))

  for idx, (q_header, c_header) in enumerate(question_comment_column_header_pairs):
    df[q_header] = df[q_header].fillna(default_score_func(idx))
    df[c_header] = df[c_header].fillna(default_answer_func(idx))

  students = {}
  for _, row in df.iterrows():
    scores = [
      row[q_header]
      for idx, (q_header, c_header) in enumerate(question_comment_column_header_pairs)
    ]
    comments = [
      row[c_header]
      for idx, (q_header, c_header) in enumerate(question_comment_column_header_pairs)
    ]
    student = Student(
      row["Student Name"],
      row["User Name"],
      scores,
      comments
    )
    students[student.student_name] = student

  return students


def load_and_update_html(path_to_html, students_dict, assignment_number, supress_assignment_number):
  """Loads HTML via beautiful soup and uses the student dict to update scores in place.  Returns string"""
  table_soup = bs4.BeautifulSoup(open(path_to_html).read(), features="html.parser")
  found_assignment_number = table_soup.find_all("input")[0]["value"]
  # Check to make sure we're doing the same assignment
  if not supress_assignment_number:
    print(f"assignment_number: {assignment_number}")
    print(f"found_assignment_number: {found_assignment_number}")
    if assignment_number != found_assignment_number:
      raise AssignmentNumberException(f"Incorrect assignment number found! {assignment_number} != {found_assignment_number}")

  rows = table_soup.find_all("tr")
  html_students = []
  for row in rows[1:]:  # Skip the first because it's the header
    record = row.find_all("td")
    name = record[0].text.strip()
    html_students.append(name)
    input = record[2].find("input")
    try:
      input["value"] = students_dict[name].get_score()
    except KeyError as e:
      logging.warning("Cannot find score for student {name}")
      logging.warning(e)
  missing_from_html = set(students_dict.keys()).difference(set(html_students))
  missing_from_xlsx = set(html_students).difference(students_dict.keys())
  return table_soup.prettify(), missing_from_html, missing_from_xlsx


def parse_args():
  parser = argparse.ArgumentParser()

  parser.add_argument("--assignment_name", required=True)
  parser.add_argument("--overwrite_existing", action="store_true")

  parser.add_argument("--grades_excel", required=True)
  parser.add_argument("--base_html", default="")

  parser.add_argument("--assignment_number", default=None)
  parser.add_argument("--suppress_assignment_number", action="store_true")

  return parser.parse_args()


def main():
  args = parse_args()

  output_dir = args.assignment_name
  if os.path.exists(output_dir):
    if not args.overwrite_existing:
      logging.error(
        "Assignment output folder already exists.  Please use --overwrite_existing if you wish to overwrite")
      exit(0)
    shutil.rmtree(output_dir)
  os.mkdir(output_dir)

  students_dict = load_excel_to_students_dict(args.grades_excel, default_score_func=get_default_score_func(), default_answer_func=get_default_answers_func())
  try:
    new_html, missing_from_html, missing_from_xlsx = load_and_update_html(
      args.base_html,
      students_dict,
      args.assignment_number,
      args.suppress_assignment_number
    )
  except AssignmentNumberException as e:
    logging.error(e)
    exit(0)

  with open(os.path.join(output_dir, f"{args.assignment_name}_table.html"), 'w') as o_fid:
    o_fid.write(new_html)

  with zipfile.ZipFile(os.path.join(output_dir, f"{args.assignment_name}_comments.zip"), 'w') as z_fid:
    for student in students_dict.values():
      z_fid.writestr(
        os.path.join("comments", f"{student.username}.txt"),
        student.get_comment()
      )

  if len(missing_from_html) > 0:
    print("!! Missing Students from HTML !!")
    for student in missing_from_html:
      print(f"  Missing entry in html for {student}")

  if len(missing_from_xlsx) > 0:
    print("!! Missing Students from HTML !!")
    for student in missing_from_xlsx:
      print(f"  Missing entry in html for {student}")

  print("")

  students_with_zero = list(filter((lambda s: s.get_score() == 0.), students_dict.values()))
  if len(students_with_zero) > 0:
    print("!! Students with score of 0!!")
    for student in students_with_zero:
      print(f"  Score of 0 record for student {student.student_name}")
  else:
    print("All students have non-zero score")

  return


if __name__ == "__main__":
  main()
